#include "go4_unpack_struct.common"

/*
Below is autogenerated structure: TIMESTAMP_WHITERABBIT
Do not edit these definitions!
*/

#ifndef _GO4_UNPACK_STRUCTURE_TIMESTAMP_WHITERABBIT_HH
#define _GO4_UNPACK_STRUCTURE_TIMESTAMP_WHITERABBIT_HH
template <uint32_t id, typename __T = void> 
struct TIMESTAMP_WHITERABBIT {
  Go4UnpackPtr<DATA16> subsystem_id;
  Go4UnpackPtr<DATA16> tll;
  Go4UnpackPtr<DATA16> tlh;
  Go4UnpackPtr<DATA16> thl;
  Go4UnpackPtr<DATA16> thh;
  __u32<> header;
  __u32<> d1;
  __u32<> d2;
  __u32<> d3;
  __u32<> d4;
  TIMESTAMP_WHITERABBIT() = default;

  void init() {
    subsystem_id.assign(&header, 0, 11);
    tll.assign(&d1, 0, 15);
    tlh.assign(&d2, 0, 15);
    thl.assign(&d3, 0, 15);
    thh.assign(&d4, 0, 15);
  }

  static constexpr size_t min_size() {
    size_t struct_size = 0;
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    return struct_size;
  }

  bool check_event() {
    bool __b = 1;
    {
      uint32_t __mask = (uint32_t)((1ull << (11 - (0))) - 1);
      uint32_t __word = (uint32_t)(this->header >> (0));
      if(__b &= ((__word & __mask) == (id)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mTIMESTAMP_WHITERABBIT.header[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", id, __word & __mask);
        return 0;
      }
    }
    {
      uint32_t __mask = (uint32_t)((1ull << (15 - (12))) - 1);
      uint32_t __word = (uint32_t)(this->header >> (12));
      if(__b &= ((__word & __mask) == (0)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mTIMESTAMP_WHITERABBIT.header[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", 0, __word & __mask);
        return 0;
      }
    }
    {
      uint32_t __word = (uint32_t)(this->header >> (16));
      if(__b &= ((__word & 1) == (0)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mTIMESTAMP_WHITERABBIT.header[31m .[0m");
        printerr("Expected [36m0x%x[0m, found: [31m0x%x[0m.\n", 0, __word & 1);
        return 0;
      }
    }
    {
      uint32_t __mask = (uint32_t)((1ull << (31 - (17))) - 1);
      uint32_t __word = (uint32_t)(this->header >> (17));
      if(__b &= ((__word & __mask) == (0)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mTIMESTAMP_WHITERABBIT.header[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", 0, __word & __mask);
        return 0;
      }
    }
    {
      uint32_t __mask = (uint32_t)((1ull << (31 - (16))) - 1);
      uint32_t __word = (uint32_t)(this->d1 >> (16));
      if(__b &= ((__word & __mask) == (0x03e1)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mTIMESTAMP_WHITERABBIT.d1[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", 0x03e1, __word & __mask);
        return 0;
      }
    }
    {
      uint32_t __mask = (uint32_t)((1ull << (31 - (16))) - 1);
      uint32_t __word = (uint32_t)(this->d2 >> (16));
      if(__b &= ((__word & __mask) == (0x04e1)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mTIMESTAMP_WHITERABBIT.d2[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", 0x04e1, __word & __mask);
        return 0;
      }
    }
    {
      uint32_t __mask = (uint32_t)((1ull << (31 - (16))) - 1);
      uint32_t __word = (uint32_t)(this->d3 >> (16));
      if(__b &= ((__word & __mask) == (0x05e1)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mTIMESTAMP_WHITERABBIT.d3[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", 0x05e1, __word & __mask);
        return 0;
      }
    }
    {
      uint32_t __mask = (uint32_t)((1ull << (31 - (16))) - 1);
      uint32_t __word = (uint32_t)(this->d4 >> (16));
      if(__b &= ((__word & __mask) == (0x06e1)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mTIMESTAMP_WHITERABBIT.d4[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", 0x06e1, __word & __mask);
        return 0;
      }
    }
    return __b;
  }

  void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
    if(min_size() > bytes_available) throw std::runtime_error("Subevent boundary reached. Cannot read anymore.");
    bytes_read = 0;
    size_t bytes_read_sub = 0;
    header.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    d1.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    d2.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    d3.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    d4.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
  }

  void clear() {
    header.clear();
    d1.clear();
    d2.clear();
    d3.clear();
    d4.clear();
  }
};
#endif /* _GO4_UNPACK_STRUCTURE_TIMESTAMP_WHITERABBIT_HH */

/*
Below is autogenerated structure: BASIC
Do not edit these definitions!
*/

#ifndef _GO4_UNPACK_STRUCTURE_BASIC_HH
#define _GO4_UNPACK_STRUCTURE_BASIC_HH
template <uint32_t chann_num, uint32_t bit_id, typename __T = void> 
struct BASIC {
  Go4UnpackPtr<DATA8> y_id;
  Go4UnpackPtr<DATA32> z_id;
  Go4UnpackPtr<DATA16> hit_id[chann_num];
#define _MAX_DYN 4
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
      for(int _i = 0; _i < _MAX_DYN; ++_i) data[_i].init();
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    inline bool check_current() {
      return data[num_items] == 0xfefefefe;
    }
  } x;
#undef _MAX_DYN
  __U64<> y;
#define i 0
  __U32<> word_0;
#undef i
#define i 1
  __U32<> word_1;
#undef i
#define i 2
  __U32<> word_2;
#undef i
#define i 3
  __U32<> word_3;
#undef i
#define _MAX_DYN MAX_DYN_DEFAULT
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
    for(int _i = 0; _i < _MAX_DYN; ++_i)
      z_id.assign(&data[_i], bit_id, 31);
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    bool check_current() {
      bool __b = 1;
      {
        uint32_t __mask = (uint32_t)((1ull << (bit_id - (0))) - 1);
        uint32_t __word = (uint32_t)(data[num_items] >> (0));
        if(__b &= ((__word & __mask) == (0xfeaa)); !__b) return 0;
      }
    }
  } z;
#undef _MAX_DYN
  BASIC() = default;

  void init() {
    x.init();
    y_id.assign(&y, 26, 31);
#define i 0
#undef i
#define i 1
#undef i
#define i 2
#undef i
#define i 3
#undef i
    z.init();
  }

  static constexpr size_t min_size() {
    size_t struct_size = 0;
    struct_size += __U64<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    return struct_size;
  }

  bool check_event() {
    bool __b = 1;
    {
      uint32_t __mask = (uint32_t)((1ull << (10 - (0))) - 1);
      uint32_t __word = (uint32_t)(this->y >> (0));
      if(__b &= ((__word & __mask) == (T)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mBASIC.y[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", T, __word & __mask);
        return 0;
      }
    }
    {
      uint32_t __mask = (uint32_t)((1ull << (25 - (13))) - 1);
      uint32_t __word = (uint32_t)(this->y >> (13));
      if(__b &= ((__word & __mask) == (0xfea)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mBASIC.y[31m .[0m");
        printerr("Expected [36m0x%8x[0m, found: [31m0x%8x[0m.\n", 0xfea, __word & __mask);
        return 0;
      }
    }
    {
      uint32_t __word = (uint32_t)(this->y >> (11));
      if(__b &= ((__word & 1) == (0x1)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mBASIC.y[31m .[0m");
        printerr("Expected [36m0x%x[0m, found: [31m0x%x[0m.\n", 0x1, __word & 1);
        return 0;
      }
    }
    {
      uint32_t __word = (uint32_t)(this->y >> (12));
      if(__b &= ((__word & 1) == (0x0)); !__b) {
        printerr("[31mEvent mismatch! In structure: [35mBASIC.y[31m .[0m");
        printerr("Expected [36m0x%x[0m, found: [31m0x%x[0m.\n", 0x0, __word & 1);
        return 0;
      }
    }
#define i 0
#undef i
#define i 1
#undef i
#define i 2
#undef i
#define i 3
#undef i
    return __b;
  }

  void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
    if(min_size() > bytes_available) throw std::runtime_error("Subevent boundary reached. Cannot read anymore.");
    bytes_read = 0;
    size_t bytes_read_sub = 0;
    x.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    y.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#define i 0
    word_0.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#undef i
#define i 1
    word_1.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#undef i
#define i 2
    word_2.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#undef i
#define i 3
    word_3.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#undef i
    z.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
  }

  void clear() {
    x.clear();
    y.clear();
    word_0.clear();
    word_1.clear();
    word_2.clear();
    word_3.clear();
    z.clear();
  }
};
#endif /* _GO4_UNPACK_STRUCTURE_BASIC_HH */

/*
Below is autogenerated structure: ROFL
Do not edit these definitions!
*/

#ifndef _GO4_UNPACK_STRUCTURE_ROFL_HH
#define _GO4_UNPACK_STRUCTURE_ROFL_HH
template <typename __T = void> 
struct ROFL {
  Go4UnpackPtr<DATA16> _u_enc[200];
  Go4UnpackPtr<DATA8> _uu_enc[200];
#define _MAX_DYN MAX_DYN_DEFAULT
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
      for(int _i = 0; _i < _MAX_DYN; ++_i) data[_i].init();
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    inline bool check_current() {
      return data[num_items] == 0xfefefefe;
    }
  } _x;
#undef _MAX_DYN
#define _MAX_DYN MAX_DYN_DEFAULT
  struct {
    unsigned num_items = 0;
    _BASIC<12,5,void> data[_MAX_DYN];
    void init() {
      for(int _i = 0; _i < _MAX_DYN; ++_i) data[_i].init();
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _BASIC::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    inline bool check_current() {
      return data[num_items].check_event();
    }
  } b;
#undef _MAX_DYN
#define _MAX_DYN MAX_DYN_DEFAULT
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
    for(int _i = 0; _i < _MAX_DYN; ++_i)
      _u_enc.assign(&data[_i], 7, 15);
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    bool check_current() {
      bool __b = 1;
      {
        uint32_t __mask = (uint32_t)((1ull << (5 - (0))) - 1);
        uint32_t __word = (uint32_t)(data[num_items] >> (0));
        if(__b &= ((__word & __mask) == (0xf)); !__b) return 0;
      }
      {
        uint32_t __word = (uint32_t)(data[num_items] >> (6));
        if(__b &= ((__word & 1) == (0)); !__b) return 0;
      }
    }
  } _u;
#undef _MAX_DYN
  ROFL() = default;

  void init() {
    _x.init();
    b.init();
    _u.init();
  }

  static constexpr size_t min_size() {
    size_t struct_size = 0;
    return struct_size;
  }

  bool check_event() {
    bool __b = 1;
    return __b;
  }

  void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
    if(min_size() > bytes_available) throw std::runtime_error("Subevent boundary reached. Cannot read anymore.");
    bytes_read = 0;
    size_t bytes_read_sub = 0;
    _x.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    b.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    _u.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
  }

  void clear() {
    _x.clear();
    b.clear();
    _u.clear();
  }
};
#endif /* _GO4_UNPACK_STRUCTURE_ROFL_HH */

