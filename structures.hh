#include "go4_unpack_struct.common"

/*
Below is autogenerated structure: TIMESTAMP_WHITERABBIT
Do not edit these definitions!
*/

#ifndef __GO4_UNPACK_STRUCTURE_TIMESTAMP_WHITERABBIT_HH__
#define __GO4_UNPACK_STRUCTURE_TIMESTAMP_WHITERABBIT_HH__
template <uint32_t id, typename __T = void> 
struct __TIMESTAMP_WHITERABBIT {
  Go4UnpackPtr<DATA16> subsystem_id;
  Go4UnpackPtr<DATA16> tll;
  Go4UnpackPtr<DATA16> tlh;
  Go4UnpackPtr<DATA16> thl;
  Go4UnpackPtr<DATA16> thh;
  __u32<> header;
  __u32<> d1;
  __u32<> d2;
  __u32<> d3;
  __u32<> d4;
  TIMESTAMP_WHITERABBIT() = default;

  void init() {
    subsystem_id.assign(&header, 0, 11);
    tll.assign(&d1, 0, 15);
    tlh.assign(&d2, 0, 15);
    thl.assign(&d3, 0, 15);
    thh.assign(&d4, 0, 15);
  }

  static constexpr size_t min_size() {
    size_t struct_size = 0;
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    return struct_size;
  }

  void check_event() {
    bool __b = 1;
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    struct_size += __u32<>::min_size();
    return __b;
  }

  void fill(uint8_t* __event_handle, size_t& bytes_available, size_t& bytes_read) {
    if(min_size() > bytes_available) throw std::runtime_error("Subevent boundary reached. Cannot read anymore.");
    bytes_read = 0;
    size_t bytes_read_sub = 0;
    header.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    d1.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    d2.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    d3.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    d4.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
  }

  void clear() {
    header.clear();
    d1.clear();
    d2.clear();
    d3.clear();
    d4.clear();
  }
};
#endif /* __GO4_UNPACK_STRUCTURE_TIMESTAMP_WHITERABBIT_HH__ */

/*
Below is autogenerated structure: BASIC
Do not edit these definitions!
*/

#ifndef __GO4_UNPACK_STRUCTURE_BASIC_HH__
#define __GO4_UNPACK_STRUCTURE_BASIC_HH__
template <uint32_t basic_param, typename __T = void> 
struct __BASIC {
  Go4UnpackPtr<DATA8> y_id;
  Go4UnpackPtr<DATA16> hit_id[100];
#define _MAX_DYN 4
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
      for(int _i = 0; _i < _MAX_DYN; ++_i) data[_i].init();
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    inline bool check_current() {
      return data[num_items] == 0xfefefefe;
    }
  } x;
#undef _MAX_DYN
  __U64<> y;
#define i 0
  __U32<> word_0;
#undef i
#define i 1
  __U32<> word_1;
#undef i
#define i 2
  __U32<> word_2;
#undef i
#define i 3
  __U32<> word_3;
#undef i
#define _MAX_DYN 128
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
    for(int _i = 0; _i < MAX_DYN; ++_i)
      hit_id.assign(&data[_i], bit_id, 31);
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    bool check_current() {
      bool __b = 1;
      {
        uint32_t __mask = (uint32_t)((1ull << (bit_id - (0))) - 1);
        uint32_t __word = (uint32_t)(data[num_items] >> (0));        if(__b &= ((__word & __mask) == (0xfeaa)); !__b) return 0;      }
    }
  } z;
#undef _MAX_DYN
  BASIC() = default;

  void init() {
    x.init();
    y_id.assign(&y, 26, 31);
#define i 0
#undef i
#define i 1
#undef i
#define i 2
#undef i
#define i 3
#undef i
    z.init();
  }

  static constexpr size_t min_size() {
    size_t struct_size = 0;
    struct_size += __U64<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    return struct_size;
  }

  void check_event() {
    bool __b = 1;
    struct_size += __U64<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    struct_size += __U32<>::min_size();
    return __b;
  }

  void fill(uint8_t* __event_handle, size_t& bytes_available, size_t& bytes_read) {
    if(min_size() > bytes_available) throw std::runtime_error("Subevent boundary reached. Cannot read anymore.");
    bytes_read = 0;
    size_t bytes_read_sub = 0;
    x.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    y.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#define i 0
    word_0.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#undef i
#define i 1
    word_1.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#undef i
#define i 2
    word_2.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#undef i
#define i 3
    word_3.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
#undef i
    z.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
  }

  void clear() {
    x.clear();
    y.clear();
    word_0.clear();
    word_1.clear();
    word_2.clear();
    word_3.clear();
    z.clear();
  }
};
#endif /* __GO4_UNPACK_STRUCTURE_BASIC_HH__ */

/*
Below is autogenerated structure: ROFL
Do not edit these definitions!
*/

#ifndef __GO4_UNPACK_STRUCTURE_ROFL_HH__
#define __GO4_UNPACK_STRUCTURE_ROFL_HH__
template <typename __T = void> 
struct __ROFL {
  Go4UnpackPtr<DATA16> _u_enc[200];
  Go4UnpackPtr<DATA8> _uu_enc[200];
#define _MAX_DYN 128
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
      for(int _i = 0; _i < _MAX_DYN; ++_i) data[_i].init();
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    inline bool check_current() {
      return data[num_items] == 0xfefefefe;
    }
  } _x;
#undef _MAX_DYN
#define _MAX_DYN 4
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
      for(int _i = 0; _i < _MAX_DYN; ++_i) data[_i].init();
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    inline bool check_current() {
      return data[num_items] == 0x11111111;
    }
  } _xx;
#undef _MAX_DYN
#define _MAX_DYN MAX_DYN_DEFAULT
  struct {
    unsigned num_items = 0;
    _BASIC<12,void> data[_MAX_DYN];
    void init() {
      for(int _i = 0; _i < _MAX_DYN; ++_i) data[_i].init();
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _BASIC::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    inline bool check_current() {
      return data[num_items].check_event();
    }
  } b;
#undef _MAX_DYN
#define _MAX_DYN 2
  struct {
    unsigned num_items = 0;
    _BASIC<12,void> data[_MAX_DYN];
    void init() {
      for(int _i = 0; _i < _MAX_DYN; ++_i) data[_i].init();
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _BASIC::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    inline bool check_current() {
      return data[num_items].check_event();
    }
  } bb;
#undef _MAX_DYN
#define _MAX_DYN 128
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
    for(int _i = 0; _i < MAX_DYN; ++_i)
      _u_enc.assign(&data[_i], 7, 15);
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    bool check_current() {
      bool __b = 1;
      {
        uint32_t __mask = (uint32_t)((1ull << (5 - (0))) - 1);
        uint32_t __word = (uint32_t)(data[num_items] >> (0));        if(__b &= ((__word & __mask) == (0xf)); !__b) return 0;      }
    {
        uint32_t __word = (uint32_t)(data[num_items] >> (6));        if(__b &= ((__word & 1) == (0)); !__b) return 0;      }
    }
  } _u;
#undef _MAX_DYN
#define _MAX_DYN 128
  struct {
    unsigned num_items = 0;
    _U32<void> data[_MAX_DYN];
    void init() {
    for(int _i = 0; _i < MAX_DYN; ++_i)
      _uu_enc.assign(&data[_i], 10, 15);
    }
    void fill(uint8_t* event_handle, size_t& bytes_available, size_t& bytes_read) {
      bytes_read = 0;
      size_t bytes_read_sub;
      while(bytes_available < _U32::min_size() && num_items < _MAX_DYN) {
        data[num_items].fill(event_handle, bytes_available, bytes_read_sub);
        if(!check_current()) {
          data[num_items].clear();
          break;
        }
        event_handle += bytes_read_sub;
        bytes_read += bytes_read_sub;
        num_items++;
      }
    }
    inline void clear() noexcept {
      for(int _i = 0; _i < num_items; ++_i) data[_i].clear();
    }
    bool check_current() {
      bool __b = 1;
      {
        uint32_t __mask = (uint32_t)((1ull << (8 - (0))) - 1);
        uint32_t __word = (uint32_t)(data[num_items] >> (0));        if(__b &= ((__word & __mask) == (0xf)); !__b) return 0;      }
    {
        uint32_t __word = (uint32_t)(data[num_items] >> (9));        if(__b &= ((__word & 1) == (0)); !__b) return 0;      }
    }
  } _u;
#undef _MAX_DYN
  ROFL() = default;

  void init() {
    _x.init();
    _xx.init();
    b.init();
    bb.init();
    _u.init();
    _u.init();
  }

  static constexpr size_t min_size() {
    size_t struct_size = 0;
    return struct_size;
  }

  void check_event() {
    bool __b = 1;
    return __b;
  }

  void fill(uint8_t* __event_handle, size_t& bytes_available, size_t& bytes_read) {
    if(min_size() > bytes_available) throw std::runtime_error("Subevent boundary reached. Cannot read anymore.");
    bytes_read = 0;
    size_t bytes_read_sub = 0;
    _x.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    _xx.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    b.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    bb.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    _u.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
    _u.fill(event_handle, bytes_available, bytes_read_sub);
    event_handle += bytes_read_sub;
    bytes_read += bytes_read_sub;
  }

  void clear() {
    _x.clear();
    _xx.clear();
    b.clear();
    bb.clear();
    _u.clear();
    _u.clear();
  }
};
#endif /* __GO4_UNPACK_STRUCTURE_ROFL_HH__ */

