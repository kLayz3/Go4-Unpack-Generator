#[macro_export]
macro_rules! formatt {
    ($tab_count:expr; $($arg:tt)*) => {
        format!("{}","  ".repeat($tab_count)) + &format!($($arg)*)
    }
}

#[macro_export] 
macro_rules! parse_spec_file { 
    ( $( $name:ident ( $($generic:ident),*) { $($body:tt)* }; )*
      $( @SUBEVENT($subev_name:ident) { $($subev_body:tt)* }; )* 
      $( @EVENT { $($event_body:tt)* }; )?
    ) => {
        $( parse_struct!($name ($($generic),*) { $($body)* } ; ) ; )*
        $( parse_subev!($subev_name { $($subev_body)* } ) ; )*
        $( parse_event!( $($event_body)* ); )?
    };
}

#[macro_export]
macro_rules! parse_struct {
    ($name:ident( $($generic:ident),*) { $($body:tt)* };) => {
        let mut __s = String::new();
        let __file_name = format!("{}.struct", stringify!($name));
        let mut __file = File::create(&__file_name)?;
        __s += "/*\n";
        __s += &format!("Below is autogenerated structure: {}\n", stringify!($name));
        __s += &format!("Do not edit these definitions!\n");
        __s += "*/\n\n";
        __s += &format!("#ifndef __GO4_UNPACK_STRUCTURE_{}_HH__\n", stringify!($name)); 
        __s += &format!("#define __GO4_UNPACK_STRUCTURE_{}_HH__\n", stringify!($name)); 
        __s += "template <";
        __s += &parse_generics!( $($generic),*);
        __s += &format!("typename __T = void> \nstruct __{} {{\n", stringify!($name));

        // Create fields:
        __s += &parse_fields!(@$($body)* );

        // Create a default ctor
        __s += &formatt!(1; "{}() = default;\n\n", stringify!($name));

        // Create an `init()` method that initializes MEMBERs and calls `init()` of underlying fields 
        __s += &formatt!(1; "void init() {{\n");
        __s += &parse_init!(@$($body)* );
        __s += &formatt!(1; "}}\n\n");
 
        // Create the static __min_size() 
        __s += &formatt!(1; "static constexpr size_t min_size() {{\n");
        __s += &formatt!(2; "size_t struct_size = 0;\n");
        __s += &parse_size!(@$($body)* );
        __s += &formatt!(2; "return struct_size;\n");
        __s += &formatt!(1; "}}\n");

        // Create check_event() method: 
        __s += "\n";
        __s += &formatt!(1; "void check_event() {{\n");
        __s += &formatt!(2; "bool __b = 1;\n");
        __s += &parse_condition!( $name $($body)*);
        __s += &formatt!(2; "return __b;\n");
        __s += &formatt!(1; "}}\n\n");

        // Create fill() method:
        __s += &formatt!(1; "void fill(uint8_t* __event_handle, size_t& bytes_available, size_t& bytes_read) {{\n");
        __s += &formatt!(2; "if(min_size() > bytes_available) throw std::runtime_error(\"Subevent boundary reached. Cannot read anymore.\");\n");
        __s += &formatt!(2; "bytes_read = 0;\n");
        __s += &formatt!(2; "size_t bytes_read_sub = 0;\n");
        __s += &parse_fill!(@$($body)* );
        __s += &formatt!(1; "}}\n\n"); 

        // Create clear() method:
        __s += &formatt!(1; "void clear() {{\n");
        __s += &parse_clear!(@$($body)*);
        __s += &formatt!(1; "}}\n"); 
       
        __s += &format!("}};\n");
        __s += &format!("#endif /* __GO4_UNPACK_STRUCTURE_{}_HH__ */", stringify!($name)); 
        __s += "\n\n";


        __file.write(__s.as_bytes())?;
        thread::sleep(Duration::from_millis(10));
    };

    () => {};
}

#[macro_export]
macro_rules! parse_subev { 
    // Ignore subevent and event tokens
    ($name:ident { $($body:tt)* } ) => {
        // there should not be any encodes or struct definitions here.
        // Here shall be only pure declarations, no `for` loops.
        // in the format of composite types: 
        // `` name = type(gen_id = gen_val, ...); `` 
        let mut __s = String::new();
        __s += "#include \"structures.hh\"";
        let mut __s = String::new();
        let __file_name = format!("{}.subev", stringify!($name));
        let mut __file = File::create(&__file_name)?;
        __s += "/*\n";
        __s += &format!("Below is autogenerated structure: {}\n", stringify!($name));
        __s += &format!("Do not edit these definitions!\n");
        __s += "*/\n\n";
        __s += &format!("#ifndef __GO4_UNPACK_SUBEVENT_{}_HH__\n", stringify!($name)); 
        __s += &format!("#define __GO4_UNPACK_SUBEVENT_{}_HH__\n", stringify!($name)); 
        __s += &format!("class __{} {{\n", stringify!($name));

        // Create fields:
        __s += &parse_fields!(@$($body)* );

        // Create a default ctor
        __s += &formatt!(1; "{}() = default;\n\n", stringify!($name));

        // Create an `init()` method that initializes MEMBERs and calls `init()` of underlying fields 
        __s += &formatt!(1; "void init() {{\n");
        __s += &parse_init!(@$($body)* );
        __s += &formatt!(1; "}}\n\n");
 
        // Create check_event() method: 
        __s += "\n";
        __s += &formatt!(1; "void check_event() {{\n");
        __s += &formatt!(2; "bool __b = 1;\n");
        __s += &parse_condition!( $name $($body)*);
        __s += &formatt!(2; "return __b;\n");
        __s += &formatt!(1; "}}\n\n");

        // Create fill() method:
        __s += &formatt!(1; "void fill(uint8_t* __event_handle, size_t& bytes_available, size_t& bytes_read) {{\n");
        __s += &formatt!(2; "bytes_read = 0;\n");
        __s += &formatt!(2; "size_t bytes_read_sub = 0;\n");
        __s += &parse_fill!(@$($body)* );
        __s += &formatt!(1; "}}\n\n"); 

        // Create clear() method:
        __s += &formatt!(1; "void clear() {{\n");
        __s += &parse_clear!(@$($body)*);
        __s += &formatt!(1; "}}\n"); 

        __s += &format!("}};\n");
        __s += &format!("#endif /* __GO4_UNPACK_STRUCTURE_{}_HH__ */", stringify!($name)); 
        __s += "\n\n";
        __file.write(__s.as_bytes())?;

    };
    () => {};
}

#[macro_export]
macro_rules! parse_event { 
    ( $($body:tt)* ; ) => {
        // there should not be any encodes or struct definitions here.
        // Here are only subevent names with one specific format:
        // `` name = subevent_name(type=T, subtype=ST, \
        // control=CT, procid=procID, crate=CR, subcrate=subCR); ``
        
        // subevent specifiers can be ommited as long as different specified subevents are
        // distincted in the LMD data, else it shall fail.
        //
        // todo!
    };
    () => {};
}

include!("parse_generics.rs");
include!("parse_fields.rs");
include!("parse_init.rs");
include!("parse_size.rs");
include!("parse_condition.rs");
include!("parse_fill.rs");
include!("parse_clear.rs");
